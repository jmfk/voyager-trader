"""
Strategy models for VOYAGER-Trader.

This module defines models for trading strategies, signals, rules,
and backtesting results.
"""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field, field_validator

from .base import BaseEntity
from .types import Money, SignalStrength, SignalType, StrategyStatus, Symbol, TimeFrame


class RuleOperator(str, Enum):
    """Operators for combining trading rules."""

    AND = "and"
    OR = "or"
    NOT = "not"
    GREATER_THAN = "gt"
    LESS_THAN = "lt"
    EQUAL = "eq"
    GREATER_EQUAL = "gte"
    LESS_EQUAL = "lte"


class IndicatorType(str, Enum):
    """Types of technical indicators."""

    SMA = "sma"  # Simple Moving Average
    EMA = "ema"  # Exponential Moving Average
    RSI = "rsi"  # Relative Strength Index
    MACD = "macd"  # Moving Average Convergence Divergence
    BOLLINGER_BANDS = "bollinger_bands"
    STOCHASTIC = "stochastic"
    ATR = "atr"  # Average True Range
    VOLUME = "volume"
    PRICE = "price"
    CUSTOM = "custom"


class BacktestMetric(str, Enum):
    """Backtesting performance metrics."""

    TOTAL_RETURN = "total_return"
    ANNUALIZED_RETURN = "annualized_return"
    SHARPE_RATIO = "sharpe_ratio"
    MAX_DRAWDOWN = "max_drawdown"
    WIN_RATE = "win_rate"
    PROFIT_FACTOR = "profit_factor"
    CALMAR_RATIO = "calmar_ratio"
    SORTINO_RATIO = "sortino_ratio"
    VAR_95 = "var_95"  # Value at Risk 95%


class Signal(BaseEntity):
    """
    Trading signal entity.

    Represents a trading signal generated by a strategy with
    confidence, timing, and execution parameters.
    """

    symbol: Symbol = Field(description="Signal symbol")
    signal_type: SignalType = Field(description="Type of signal")
    strength: SignalStrength = Field(description="Signal strength")
    confidence: Decimal = Field(description="Signal confidence (0-100)")
    timestamp: datetime = Field(description="Signal generation timestamp")
    expiry: Optional[datetime] = Field(
        default=None, description="Signal expiry timestamp"
    )
    target_price: Optional[Decimal] = Field(
        default=None, description="Target entry price"
    )
    stop_loss: Optional[Decimal] = Field(default=None, description="Stop loss price")
    take_profit: Optional[Decimal] = Field(
        default=None, description="Take profit price"
    )
    position_size: Optional[Decimal] = Field(
        default=None, description="Suggested position size %"
    )
    rationale: str = Field(description="Signal generation rationale")
    indicators: Dict[str, Any] = Field(
        default_factory=dict, description="Contributing indicators"
    )
    metadata: Dict[str, Any] = Field(
        default_factory=dict, description="Additional metadata"
    )
    strategy_id: str = Field(description="Originating strategy ID")

    @field_validator("confidence")
    @classmethod
    def validate_confidence(cls, v: Decimal) -> Decimal:
        """Validate confidence is between 0 and 100."""
        if isinstance(v, (int, float)):
            v = Decimal(str(v))
        if v < 0 or v > 100:
            raise ValueError("Confidence must be between 0 and 100")
        return v.quantize(Decimal("0.01"))

    @field_validator("position_size")
    @classmethod
    def validate_position_size(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate position size is between 0 and 100."""
        if v is not None:
            if isinstance(v, (int, float)):
                v = Decimal(str(v))
            if v < 0 or v > 100:
                raise ValueError("Position size must be between 0 and 100")
            return v.quantize(Decimal("0.01"))
        return v

    @field_validator("target_price", "stop_loss", "take_profit")
    @classmethod
    def validate_prices(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate price precision."""
        if v is not None:
            if isinstance(v, (int, float)):
                v = Decimal(str(v))
            if v <= 0:
                raise ValueError("Prices must be positive")
            return v.quantize(Decimal("0.00000001"))
        return v

    @property
    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.signal_type in {
            SignalType.BUY,
            SignalType.INCREASE_POSITION,
        }

    @property
    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.signal_type in {
            SignalType.SELL,
            SignalType.EXIT_LONG,
            SignalType.EXIT_SHORT,
            SignalType.REDUCE_POSITION,
        }

    @property
    def is_expired(self) -> bool:
        """Check if signal has expired."""
        if self.expiry is None:
            return False
        return datetime.utcnow() > self.expiry

    @property
    def is_high_confidence(self) -> bool:
        """Check if signal has high confidence (>75%)."""
        return self.confidence > 75

    @property
    def risk_reward_ratio(self) -> Optional[Decimal]:
        """Calculate risk/reward ratio if stop loss and take profit are set."""
        if (
            self.target_price is None
            or self.stop_loss is None
            or self.take_profit is None
        ):
            return None

        risk = abs(self.target_price - self.stop_loss)
        reward = abs(self.take_profit - self.target_price)

        if risk == 0:
            return None

        return reward / risk


class TradingRule(BaseEntity):
    """
    Trading rule entity.

    Represents an individual trading rule that can be composed
    into strategies. Rules evaluate market conditions and contribute
    to signal generation.
    """

    name: str = Field(description="Rule name")
    description: str = Field(description="Rule description")
    rule_type: str = Field(description="Type of rule (entry, exit, risk)")
    indicator_type: IndicatorType = Field(description="Primary indicator type")
    operator: RuleOperator = Field(description="Rule operator")
    parameters: Dict[str, Any] = Field(description="Rule parameters")
    conditions: List[Dict[str, Any]] = Field(description="Rule conditions")
    weight: Decimal = Field(
        default=Decimal("1.0"), description="Rule weight in strategy"
    )
    is_active: bool = Field(default=True, description="Whether rule is active")
    timeframe: Optional[TimeFrame] = Field(default=None, description="Rule timeframe")
    symbols: Optional[List[Symbol]] = Field(
        default=None, description="Applicable symbols"
    )
    code: Optional[str] = Field(default=None, description="Rule implementation code")

    @field_validator("weight")
    @classmethod
    def validate_weight(cls, v: Decimal) -> Decimal:
        """Validate rule weight."""
        if isinstance(v, (int, float)):
            v = Decimal(str(v))
        if v < 0:
            raise ValueError("Rule weight must be non-negative")
        return v.quantize(Decimal("0.01"))

    @property
    def is_entry_rule(self) -> bool:
        """Check if this is an entry rule."""
        return self.rule_type.lower() == "entry"

    @property
    def is_exit_rule(self) -> bool:
        """Check if this is an exit rule."""
        return self.rule_type.lower() == "exit"

    @property
    def is_risk_rule(self) -> bool:
        """Check if this is a risk management rule."""
        return self.rule_type.lower() == "risk"

    def evaluate(self, market_data: Dict[str, Any]) -> bool:
        """
        Evaluate rule against market data.

        This is a placeholder - actual implementation would depend on
        the specific rule logic and indicator calculations.
        """
        # Placeholder implementation
        return True

    def get_signal_contribution(self, market_data: Dict[str, Any]) -> Decimal:
        """Get rule's contribution to signal strength."""
        if not self.is_active:
            return Decimal("0")

        if self.evaluate(market_data):
            return self.weight
        else:
            return Decimal("0")


class Strategy(BaseEntity):
    """
    Trading strategy entity.

    Represents a complete trading strategy composed of multiple rules,
    risk management parameters, and performance tracking.
    """

    name: str = Field(description="Strategy name")
    description: str = Field(description="Strategy description")
    version: str = Field(default="1.0", description="Strategy version")
    status: StrategyStatus = Field(
        default=StrategyStatus.DRAFT, description="Strategy status"
    )
    entry_rules: List[str] = Field(description="Entry rule IDs")
    exit_rules: List[str] = Field(description="Exit rule IDs")
    risk_rules: List[str] = Field(description="Risk management rule IDs")
    symbols: List[Symbol] = Field(description="Applicable symbols")
    timeframes: List[TimeFrame] = Field(description="Strategy timeframes")
    max_position_size: Decimal = Field(description="Maximum position size %")
    stop_loss_percent: Optional[Decimal] = Field(
        default=None, description="Default stop loss %"
    )
    take_profit_percent: Optional[Decimal] = Field(
        default=None, description="Default take profit %"
    )
    risk_per_trade: Decimal = Field(description="Risk per trade %")
    parameters: Dict[str, Any] = Field(
        default_factory=dict, description="Strategy parameters"
    )
    performance_metrics: Dict[str, Decimal] = Field(
        default_factory=dict, description="Performance metrics"
    )
    tags: List[str] = Field(default_factory=list, description="Strategy tags")
    author: Optional[str] = Field(default=None, description="Strategy author")
    skill_ids: List[str] = Field(
        default_factory=list, description="Associated VOYAGER skill IDs"
    )

    @field_validator(
        "max_position_size",
        "stop_loss_percent",
        "take_profit_percent",
        "risk_per_trade",
    )
    @classmethod
    def validate_percentages(cls, v: Optional[Decimal]) -> Optional[Decimal]:
        """Validate percentage values."""
        if v is not None:
            if isinstance(v, (int, float)):
                v = Decimal(str(v))
            if v < 0 or v > 100:
                raise ValueError("Percentage must be between 0 and 100")
            return v.quantize(Decimal("0.01"))
        return v

    @computed_field
    @property
    def total_rules_count(self) -> int:
        """Get total number of rules in strategy."""
        return len(self.entry_rules) + len(self.exit_rules) + len(self.risk_rules)

    @property
    def is_active(self) -> bool:
        """Check if strategy is active (live trading or paper trading)."""
        return self.status in {
            StrategyStatus.LIVE_TRADING,
            StrategyStatus.PAPER_TRADING,
        }

    @property
    def is_backtesting(self) -> bool:
        """Check if strategy is in backtesting."""
        return self.status == StrategyStatus.BACKTESTING

    @property
    def is_live(self) -> bool:
        """Check if strategy is live trading."""
        return self.status == StrategyStatus.LIVE_TRADING

    @property
    def has_performance_data(self) -> bool:
        """Check if strategy has performance metrics."""
        return bool(self.performance_metrics)

    def can_generate_signals(self) -> bool:
        """Check if strategy can generate signals."""
        return self.is_active and len(self.entry_rules) > 0 and len(self.symbols) > 0

    def activate(self) -> "Strategy":
        """Activate strategy for paper trading."""
        if self.status == StrategyStatus.DRAFT:
            return self.update(status=StrategyStatus.PAPER_TRADING)
        raise ValueError(f"Cannot activate strategy in {self.status} status")

    def promote_to_live(self) -> "Strategy":
        """Promote strategy to live trading."""
        if self.status == StrategyStatus.PAPER_TRADING:
            return self.update(status=StrategyStatus.LIVE_TRADING)
        raise ValueError(f"Cannot promote strategy in {self.status} status")

    def pause(self) -> "Strategy":
        """Pause strategy execution."""
        if self.is_active:
            return self.update(status=StrategyStatus.PAUSED)
        raise ValueError(f"Cannot pause strategy in {self.status} status")

    def stop(self) -> "Strategy":
        """Stop strategy execution."""
        if self.status != StrategyStatus.STOPPED:
            return self.update(status=StrategyStatus.STOPPED)
        return self

    def update_performance(self, metrics: Dict[str, Decimal]) -> "Strategy":
        """Update strategy performance metrics."""
        updated_metrics = {**self.performance_metrics, **metrics}
        return self.update(performance_metrics=updated_metrics)

    def get_sharpe_ratio(self) -> Optional[Decimal]:
        """Get Sharpe ratio from performance metrics."""
        return self.performance_metrics.get(BacktestMetric.SHARPE_RATIO.value)

    def get_max_drawdown(self) -> Optional[Decimal]:
        """Get maximum drawdown from performance metrics."""
        return self.performance_metrics.get(BacktestMetric.MAX_DRAWDOWN.value)

    def get_win_rate(self) -> Optional[Decimal]:
        """Get win rate from performance metrics."""
        return self.performance_metrics.get(BacktestMetric.WIN_RATE.value)


class Backtest(BaseEntity):
    """
    Backtest results entity.

    Represents the results of backtesting a strategy against
    historical data with comprehensive performance metrics.
    """

    strategy_id: str = Field(description="Strategy being tested")
    start_date: datetime = Field(description="Backtest start date")
    end_date: datetime = Field(description="Backtest end date")
    initial_capital: Money = Field(description="Starting capital")
    final_capital: Money = Field(description="Ending capital")
    symbols: List[Symbol] = Field(description="Symbols tested")
    timeframes: List[TimeFrame] = Field(description="Timeframes used")
    total_trades: int = Field(description="Total number of trades")
    winning_trades: int = Field(description="Number of winning trades")
    losing_trades: int = Field(description="Number of losing trades")
    total_commission: Money = Field(description="Total commissions paid")
    metrics: Dict[str, Decimal] = Field(description="Performance metrics")
    trade_details: List[Dict[str, Any]] = Field(
        default_factory=list, description="Individual trade details"
    )
    equity_curve: List[Dict[str, Any]] = Field(
        default_factory=list, description="Equity curve data"
    )
    parameters: Dict[str, Any] = Field(
        default_factory=dict, description="Backtest parameters"
    )

    @field_validator("total_trades", "winning_trades", "losing_trades")
    @classmethod
    def validate_trade_counts(cls, v: int) -> int:
        """Validate trade counts are non-negative."""
        if v < 0:
            raise ValueError("Trade counts must be non-negative")
        return v

    def model_post_init(self, __context) -> None:
        """Validate trade count consistency."""
        if self.winning_trades + self.losing_trades > self.total_trades:
            raise ValueError("Winning + losing trades cannot exceed total trades")

    @computed_field
    @property
    def total_return(self) -> Decimal:
        """Calculate total return percentage."""
        if self.initial_capital.amount == 0:
            return Decimal("0")
        return (
            (self.final_capital.amount - self.initial_capital.amount)
            / self.initial_capital.amount
        ) * 100

    @computed_field
    @property
    def win_rate(self) -> Decimal:
        """Calculate win rate percentage."""
        if self.total_trades == 0:
            return Decimal("0")
        return (
            Decimal(str(self.winning_trades)) / Decimal(str(self.total_trades))
        ) * 100

    @computed_field
    @property
    def profit_factor(self) -> Optional[Decimal]:
        """Calculate profit factor from metrics."""
        return self.metrics.get(BacktestMetric.PROFIT_FACTOR.value)

    @computed_field
    @property
    def max_drawdown(self) -> Optional[Decimal]:
        """Get maximum drawdown percentage."""
        return self.metrics.get(BacktestMetric.MAX_DRAWDOWN.value)

    @computed_field
    @property
    def sharpe_ratio(self) -> Optional[Decimal]:
        """Get Sharpe ratio."""
        return self.metrics.get(BacktestMetric.SHARPE_RATIO.value)

    @computed_field
    @property
    def backtest_duration_days(self) -> int:
        """Calculate backtest duration in days."""
        return (self.end_date - self.start_date).days

    @computed_field
    @property
    def annualized_return(self) -> Decimal:
        """Calculate annualized return."""
        if self.backtest_duration_days == 0:
            return Decimal("0")

        years = Decimal(str(self.backtest_duration_days)) / Decimal("365.25")
        if years == 0:
            return self.total_return

        return (
            (Decimal("1") + self.total_return / 100) ** (Decimal("1") / years) - 1
        ) * 100

    @property
    def is_profitable(self) -> bool:
        """Check if backtest was profitable."""
        return self.total_return > 0

    @property
    def has_good_metrics(self) -> bool:
        """Check if backtest has good performance metrics."""
        sharpe = self.sharpe_ratio
        win_rate = self.win_rate
        max_dd = self.max_drawdown

        return (
            self.is_profitable
            and sharpe is not None
            and sharpe > Decimal("1.0")
            and win_rate > 50
            and max_dd is not None
            and max_dd < 20
        )

    def get_metric(self, metric: BacktestMetric) -> Optional[Decimal]:
        """Get specific performance metric."""
        return self.metrics.get(metric.value)

    def get_trade_summary(self) -> Dict[str, Any]:
        """Get trade summary statistics."""
        return {
            "total_trades": self.total_trades,
            "winning_trades": self.winning_trades,
            "losing_trades": self.losing_trades,
            "win_rate": float(self.win_rate),
            "total_return": float(self.total_return),
            "annualized_return": float(self.annualized_return),
            "sharpe_ratio": float(self.sharpe_ratio) if self.sharpe_ratio else None,
            "max_drawdown": float(self.max_drawdown) if self.max_drawdown else None,
        }

    def compare_to(self, other: "Backtest") -> Dict[str, str]:
        """Compare this backtest to another."""
        comparison = {}

        if self.total_return > other.total_return:
            comparison["return"] = "better"
        elif self.total_return < other.total_return:
            comparison["return"] = "worse"
        else:
            comparison["return"] = "same"

        if self.sharpe_ratio and other.sharpe_ratio:
            if self.sharpe_ratio > other.sharpe_ratio:
                comparison["risk_adjusted"] = "better"
            elif self.sharpe_ratio < other.sharpe_ratio:
                comparison["risk_adjusted"] = "worse"
            else:
                comparison["risk_adjusted"] = "same"

        if self.max_drawdown and other.max_drawdown:
            if self.max_drawdown < other.max_drawdown:
                comparison["drawdown"] = "better"
            elif self.max_drawdown > other.max_drawdown:
                comparison["drawdown"] = "worse"
            else:
                comparison["drawdown"] = "same"

        return comparison
