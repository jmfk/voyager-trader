"""
VOYAGER system models for VOYAGER-Trader.

This module defines models for VOYAGER's core system components including
Curriculum, Environment, Agent, and Task management.
"""

from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import Field, computed_field, field_validator

from .base import AggregateRoot, BaseEntity
from .types import Currency, Money, Symbol, TaskStatus, TimeFrame


class TaskPriority(str, Enum):
    """Priority levels for curriculum tasks."""

    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class TaskType(str, Enum):
    """Types of curriculum tasks."""

    LEARNING = "learning"
    EXPLORATION = "exploration"
    OPTIMIZATION = "optimization"
    VALIDATION = "validation"
    RESEARCH = "research"
    PRACTICE = "practice"
    ASSESSMENT = "assessment"


class DifficultyLevel(str, Enum):
    """Difficulty levels for tasks and curriculum."""

    BEGINNER = "beginner"
    INTERMEDIATE = "intermediate"
    ADVANCED = "advanced"
    EXPERT = "expert"


class AgentState(str, Enum):
    """States of the VOYAGER agent."""

    INITIALIZING = "initializing"
    IDLE = "idle"
    LEARNING = "learning"
    TRADING = "trading"
    OPTIMIZING = "optimizing"
    PAUSED = "paused"
    ERROR = "error"
    SHUTDOWN = "shutdown"


class EnvironmentType(str, Enum):
    """Types of trading environments."""

    SIMULATION = "simulation"
    PAPER_TRADING = "paper_trading"
    LIVE_TRADING = "live_trading"
    BACKTESTING = "backtesting"
    RESEARCH = "research"


class CurriculumStrategy(str, Enum):
    """Strategies for curriculum generation."""

    PROGRESSIVE = "progressive"  # Gradual difficulty increase
    ADAPTIVE = "adaptive"  # Based on performance
    EXPLORATORY = "exploratory"  # Novel experiences
    REINFORCEMENT = "reinforcement"  # Strengthen weak areas
    BALANCED = "balanced"  # Mix of all strategies


class Task(BaseEntity):
    """
    Curriculum task entity.

    Represents an individual learning or trading task assigned
    by the automatic curriculum system.
    """

    title: str = Field(description="Task title")
    description: str = Field(description="Task description")
    task_type: TaskType = Field(description="Type of task")
    priority: TaskPriority = Field(description="Task priority")
    difficulty: DifficultyLevel = Field(description="Task difficulty level")
    status: TaskStatus = Field(default=TaskStatus.PENDING, description="Task status")
    objectives: List[str] = Field(description="Task objectives")
    success_criteria: List[str] = Field(description="Success criteria")
    prerequisites: List[str] = Field(
        default_factory=list, description="Required prerequisite task IDs"
    )
    required_skills: List[str] = Field(
        default_factory=list, description="Required skill IDs"
    )
    target_symbols: List[Symbol] = Field(
        default_factory=list, description="Target symbols for task"
    )
    timeframe: Optional[TimeFrame] = Field(default=None, description="Task timeframe")
    estimated_duration_minutes: Optional[int] = Field(
        default=None, description="Estimated duration"
    )
    deadline: Optional[datetime] = Field(default=None, description="Task deadline")
    parameters: Dict[str, Any] = Field(
        default_factory=dict, description="Task parameters"
    )
    resources: List[str] = Field(default_factory=list, description="Required resources")
    expected_outcomes: List[str] = Field(
        default_factory=list, description="Expected outcomes"
    )
    started_at: Optional[datetime] = Field(
        default=None, description="Task start timestamp"
    )
    completed_at: Optional[datetime] = Field(
        default=None, description="Task completion timestamp"
    )
    progress_percentage: Decimal = Field(
        default=Decimal("0"), description="Task progress percentage"
    )
    results: Dict[str, Any] = Field(default_factory=dict, description="Task results")
    feedback: List[str] = Field(default_factory=list, description="Task feedback")
    lessons_learned: List[str] = Field(
        default_factory=list, description="Lessons learned"
    )
    generated_skills: List[str] = Field(
        default_factory=list, description="Skills generated by this task"
    )
    tags: List[str] = Field(default_factory=list, description="Task tags")

    @field_validator("progress_percentage")
    @classmethod
    def validate_progress(cls, v: Decimal) -> Decimal:
        """Validate progress is between 0 and 100."""
        if isinstance(v, (int, float)):
            v = Decimal(str(v))
        if v < 0 or v > 100:
            raise ValueError("Progress must be between 0 and 100")
        return v.quantize(Decimal("0.01"))

    @field_validator("estimated_duration_minutes")
    @classmethod
    def validate_duration(cls, v: Optional[int]) -> Optional[int]:
        """Validate duration is positive."""
        if v is not None and v <= 0:
            raise ValueError("Duration must be positive")
        return v

    @computed_field
    @property
    def actual_duration_minutes(self) -> Optional[int]:
        """Calculate actual task duration."""
        if self.started_at is None or self.completed_at is None:
            return None
        delta = self.completed_at - self.started_at
        return int(delta.total_seconds() / 60)

    @computed_field
    @property
    def is_overdue(self) -> bool:
        """Check if task is overdue."""
        if self.deadline is None:
            return False
        return datetime.utcnow() > self.deadline and not self.is_completed

    @property
    def is_pending(self) -> bool:
        """Check if task is pending."""
        return self.status == TaskStatus.PENDING

    @property
    def is_in_progress(self) -> bool:
        """Check if task is in progress."""
        return self.status == TaskStatus.IN_PROGRESS

    @property
    def is_completed(self) -> bool:
        """Check if task is completed."""
        return self.status == TaskStatus.COMPLETED

    @property
    def is_failed(self) -> bool:
        """Check if task failed."""
        return self.status == TaskStatus.FAILED

    @property
    def has_prerequisites(self) -> bool:
        """Check if task has prerequisites."""
        return len(self.prerequisites) > 0

    @property
    def is_high_priority(self) -> bool:
        """Check if task is high priority."""
        return self.priority in {TaskPriority.HIGH, TaskPriority.CRITICAL}

    @property
    def completion_rate(self) -> Decimal:
        """Get completion rate (alias for progress_percentage)."""
        return self.progress_percentage

    def can_start(self, completed_tasks: List[str]) -> bool:
        """Check if task can be started (prerequisites met)."""
        if not self.is_pending:
            return False
        return all(prereq in completed_tasks for prereq in self.prerequisites)

    def start_task(self) -> "Task":
        """Start the task."""
        if not self.is_pending:
            raise ValueError("Task cannot be started")

        return self.update(status=TaskStatus.IN_PROGRESS, started_at=datetime.utcnow())

    def update_progress(
        self, progress: Decimal, feedback: Optional[str] = None
    ) -> "Task":
        """Update task progress."""
        if not self.is_in_progress:
            raise ValueError("Cannot update progress on non-active task")

        new_feedback = self.feedback.copy()
        if feedback:
            new_feedback.append(feedback)

        return self.update(progress_percentage=progress, feedback=new_feedback)

    def complete_task(
        self, results: Dict[str, Any], lessons_learned: Optional[List[str]] = None
    ) -> "Task":
        """Complete the task."""
        if not self.is_in_progress:
            raise ValueError("Cannot complete non-active task")

        final_lessons = lessons_learned or []

        return self.update(
            status=TaskStatus.COMPLETED,
            completed_at=datetime.utcnow(),
            progress_percentage=Decimal("100"),
            results=results,
            lessons_learned=final_lessons,
        )

    def fail_task(self, reason: str) -> "Task":
        """Mark task as failed."""
        if not self.is_in_progress:
            raise ValueError("Cannot fail non-active task")

        new_feedback = self.feedback + [f"Failed: {reason}"]

        return self.update(
            status=TaskStatus.FAILED,
            completed_at=datetime.utcnow(),
            feedback=new_feedback,
        )

    def get_task_summary(self) -> Dict[str, Any]:
        """Get task summary."""
        return {
            "title": self.title,
            "type": self.task_type.value,
            "priority": self.priority.value,
            "difficulty": self.difficulty.value,
            "status": self.status.value,
            "progress": float(self.progress_percentage),
            "is_overdue": self.is_overdue,
            "duration_minutes": self.actual_duration_minutes,
            "objectives_count": len(self.objectives),
            "prerequisites_count": len(self.prerequisites),
            "skills_generated": len(self.generated_skills),
        }


class Environment(BaseEntity):
    """
    Trading environment entity.

    Represents the trading environment state including market
    conditions, available resources, and constraints.
    """

    name: str = Field(description="Environment name")
    environment_type: EnvironmentType = Field(description="Type of environment")
    description: str = Field(description="Environment description")
    is_active: bool = Field(default=True, description="Whether environment is active")
    base_currency: Currency = Field(description="Base currency for the environment")
    available_symbols: List[Symbol] = Field(description="Available trading symbols")
    supported_timeframes: List[TimeFrame] = Field(description="Supported timeframes")
    market_hours: Dict[str, str] = Field(description="Market hours by exchange")
    trading_constraints: Dict[str, Any] = Field(description="Trading constraints")
    risk_limits: Dict[str, Decimal] = Field(description="Risk limits")
    initial_capital: Money = Field(description="Initial capital")
    current_capital: Money = Field(description="Current available capital")
    commission_structure: Dict[str, Decimal] = Field(description="Commission structure")
    margin_requirements: Dict[str, Decimal] = Field(description="Margin requirements")
    data_providers: List[str] = Field(description="Available data providers")
    execution_venues: List[str] = Field(description="Available execution venues")
    features: List[str] = Field(description="Environment features")
    limitations: List[str] = Field(description="Environment limitations")
    configuration: Dict[str, Any] = Field(description="Environment configuration")
    metrics: Dict[str, Decimal] = Field(
        default_factory=dict, description="Environment metrics"
    )
    last_updated: datetime = Field(
        default_factory=datetime.utcnow, description="Last update timestamp"
    )

    @computed_field
    @property
    def symbol_count(self) -> int:
        """Get number of available symbols."""
        return len(self.available_symbols)

    @computed_field
    @property
    def capital_utilization(self) -> Decimal:
        """Calculate capital utilization percentage."""
        if self.initial_capital.amount == 0:
            return Decimal("0")
        used = self.initial_capital.amount - self.current_capital.amount
        return (used / self.initial_capital.amount) * 100

    @property
    def is_live_environment(self) -> bool:
        """Check if this is a live trading environment."""
        return self.environment_type == EnvironmentType.LIVE_TRADING

    @property
    def is_simulation(self) -> bool:
        """Check if this is a simulation environment."""
        return self.environment_type in {
            EnvironmentType.SIMULATION,
            EnvironmentType.PAPER_TRADING,
            EnvironmentType.BACKTESTING,
        }

    @property
    def supports_real_money(self) -> bool:
        """Check if environment supports real money trading."""
        return self.environment_type == EnvironmentType.LIVE_TRADING

    def can_trade_symbol(self, symbol: Symbol) -> bool:
        """Check if symbol can be traded in this environment."""
        return symbol in self.available_symbols

    def get_risk_limit(self, limit_type: str) -> Optional[Decimal]:
        """Get specific risk limit."""
        return self.risk_limits.get(limit_type)

    def update_capital(self, new_capital: Money) -> "Environment":
        """Update current capital."""
        return self.update(current_capital=new_capital, last_updated=datetime.utcnow())

    def add_symbol(self, symbol: Symbol) -> "Environment":
        """Add a symbol to available symbols."""
        if symbol not in self.available_symbols:
            new_symbols = self.available_symbols + [symbol]
            return self.update(available_symbols=new_symbols)
        return self

    def remove_symbol(self, symbol: Symbol) -> "Environment":
        """Remove a symbol from available symbols."""
        if symbol in self.available_symbols:
            new_symbols = [s for s in self.available_symbols if s != symbol]
            return self.update(available_symbols=new_symbols)
        return self

    def update_metrics(self, metrics: Dict[str, Decimal]) -> "Environment":
        """Update environment metrics."""
        updated_metrics = {**self.metrics, **metrics}
        return self.update(metrics=updated_metrics, last_updated=datetime.utcnow())


class Agent(BaseEntity):
    """
    VOYAGER agent entity.

    Represents the autonomous trading agent with its state,
    capabilities, performance, and learning progress.
    """

    name: str = Field(description="Agent name")
    version: str = Field(default="1.0", description="Agent version")
    state: AgentState = Field(
        default=AgentState.INITIALIZING, description="Current agent state"
    )
    description: str = Field(description="Agent description")
    capabilities: List[str] = Field(description="Agent capabilities")
    learned_skills: List[str] = Field(
        default_factory=list, description="Learned skill IDs"
    )
    active_tasks: List[str] = Field(default_factory=list, description="Active task IDs")
    completed_tasks: List[str] = Field(
        default_factory=list, description="Completed task IDs"
    )
    current_environment_id: Optional[str] = Field(
        default=None, description="Current environment ID"
    )
    performance_metrics: Dict[str, Decimal] = Field(
        default_factory=dict, description="Performance metrics"
    )
    learning_progress: Dict[str, Decimal] = Field(
        default_factory=dict, description="Learning progress by category"
    )
    experience_count: int = Field(default=0, description="Total experiences")
    knowledge_items: int = Field(default=0, description="Total knowledge items")
    trading_sessions: int = Field(default=0, description="Number of trading sessions")
    total_trades: int = Field(default=0, description="Total trades executed")
    successful_trades: int = Field(default=0, description="Successful trades")
    total_pnl: Money = Field(
        default_factory=lambda: Money(amount=Decimal("0"), currency=Currency.USD)
    )
    configuration: Dict[str, Any] = Field(
        default_factory=dict, description="Agent configuration"
    )
    preferences: Dict[str, Any] = Field(
        default_factory=dict, description="Agent preferences"
    )
    last_activity: datetime = Field(
        default_factory=datetime.utcnow, description="Last activity timestamp"
    )
    uptime_minutes: int = Field(default=0, description="Total uptime in minutes")
    error_count: int = Field(default=0, description="Total errors encountered")

    @field_validator(
        "experience_count",
        "knowledge_items",
        "trading_sessions",
        "total_trades",
        "successful_trades",
        "uptime_minutes",
        "error_count",
    )
    @classmethod
    def validate_counts(cls, v: int) -> int:
        """Validate counts are non-negative."""
        if v < 0:
            raise ValueError("Counts must be non-negative")
        return v

    def model_post_init(self, __context) -> None:
        """Validate trade count consistency."""
        if self.successful_trades > self.total_trades:
            raise ValueError("Successful trades cannot exceed total trades")

    @computed_field
    @property
    def skill_count(self) -> int:
        """Get number of learned skills."""
        return len(self.learned_skills)

    @computed_field
    @property
    def active_task_count(self) -> int:
        """Get number of active tasks."""
        return len(self.active_tasks)

    @computed_field
    @property
    def task_completion_rate(self) -> Decimal:
        """Calculate task completion rate."""
        total_tasks = len(self.completed_tasks) + len(self.active_tasks)
        if total_tasks == 0:
            return Decimal("0")
        return (
            Decimal(str(len(self.completed_tasks))) / Decimal(str(total_tasks))
        ) * 100

    @computed_field
    @property
    def trade_success_rate(self) -> Decimal:
        """Calculate trade success rate."""
        if self.total_trades == 0:
            return Decimal("0")
        return (
            Decimal(str(self.successful_trades)) / Decimal(str(self.total_trades))
        ) * 100

    @computed_field
    @property
    def learning_velocity(self) -> Decimal:
        """Calculate learning velocity (skills per day)."""
        uptime_days = max(1, self.uptime_minutes / (60 * 24))
        return Decimal(str(self.skill_count)) / Decimal(str(uptime_days))

    @computed_field
    @property
    def error_rate(self) -> Decimal:
        """Calculate error rate per hour."""
        uptime_hours = max(1, self.uptime_minutes / 60)
        return Decimal(str(self.error_count)) / Decimal(str(uptime_hours))

    @property
    def is_active(self) -> bool:
        """Check if agent is in an active state."""
        return self.state in {
            AgentState.LEARNING,
            AgentState.TRADING,
            AgentState.OPTIMIZING,
        }

    @property
    def is_idle(self) -> bool:
        """Check if agent is idle."""
        return self.state == AgentState.IDLE

    @property
    def is_learning(self) -> bool:
        """Check if agent is currently learning."""
        return self.state == AgentState.LEARNING

    @property
    def is_trading(self) -> bool:
        """Check if agent is currently trading."""
        return self.state == AgentState.TRADING

    @property
    def has_errors(self) -> bool:
        """Check if agent has encountered errors."""
        return self.error_count > 0 or self.state == AgentState.ERROR

    @property
    def is_profitable(self) -> bool:
        """Check if agent is profitable."""
        return self.total_pnl.amount > 0

    def transition_to(self, new_state: AgentState, reason: str = "") -> "Agent":
        """Transition agent to new state."""
        if new_state == self.state:
            return self

        return self.update(state=new_state, last_activity=datetime.utcnow())

    def learn_skill(self, skill_id: str) -> "Agent":
        """Add a learned skill to the agent."""
        if skill_id not in self.learned_skills:
            new_skills = self.learned_skills + [skill_id]
            return self.update(learned_skills=new_skills)
        return self

    def start_task(self, task_id: str) -> "Agent":
        """Start working on a task."""
        if task_id not in self.active_tasks:
            new_active = self.active_tasks + [task_id]
            return self.update(active_tasks=new_active, last_activity=datetime.utcnow())
        return self

    def complete_task(self, task_id: str) -> "Agent":
        """Complete a task."""
        new_active = [tid for tid in self.active_tasks if tid != task_id]
        new_completed = (
            self.completed_tasks + [task_id]
            if task_id not in self.completed_tasks
            else self.completed_tasks
        )

        return self.update(
            active_tasks=new_active,
            completed_tasks=new_completed,
            last_activity=datetime.utcnow(),
        )

    def record_trade(self, successful: bool, pnl: Money) -> "Agent":
        """Record a trade execution."""
        new_total = self.total_trades + 1
        new_successful = self.successful_trades + (1 if successful else 0)
        new_pnl = Money(
            amount=self.total_pnl.amount + pnl.amount, currency=self.total_pnl.currency
        )

        return self.update(
            total_trades=new_total,
            successful_trades=new_successful,
            total_pnl=new_pnl,
            last_activity=datetime.utcnow(),
        )

    def record_error(self, error_type: str) -> "Agent":
        """Record an error."""
        return self.update(
            error_count=self.error_count + 1, last_activity=datetime.utcnow()
        )

    def update_performance(self, metrics: Dict[str, Decimal]) -> "Agent":
        """Update performance metrics."""
        updated_metrics = {**self.performance_metrics, **metrics}
        return self.update(
            performance_metrics=updated_metrics, last_activity=datetime.utcnow()
        )

    def get_agent_summary(self) -> Dict[str, Any]:
        """Get agent summary."""
        return {
            "name": self.name,
            "version": self.version,
            "state": self.state.value,
            "skill_count": self.skill_count,
            "active_tasks": self.active_task_count,
            "task_completion_rate": float(self.task_completion_rate),
            "trade_success_rate": float(self.trade_success_rate),
            "total_pnl": str(self.total_pnl),
            "is_profitable": self.is_profitable,
            "learning_velocity": float(self.learning_velocity),
            "error_rate": float(self.error_rate),
            "uptime_hours": self.uptime_minutes / 60,
        }


class Curriculum(AggregateRoot):
    """
    Automatic curriculum aggregate root.

    Manages the learning curriculum with task generation,
    difficulty progression, and adaptive learning strategies.
    """

    name: str = Field(description="Curriculum name")
    description: str = Field(description="Curriculum description")
    agent_id: str = Field(description="Associated agent ID")
    strategy: CurriculumStrategy = Field(description="Curriculum strategy")
    current_difficulty: DifficultyLevel = Field(
        default=DifficultyLevel.BEGINNER, description="Current difficulty level"
    )
    target_skills: List[str] = Field(description="Target skills to develop")
    completed_skills: List[str] = Field(
        default_factory=list, description="Completed skill categories"
    )
    active_tasks: Dict[str, str] = Field(
        default_factory=dict, description="Active task IDs by priority"
    )
    task_queue: List[str] = Field(default_factory=list, description="Queued task IDs")
    completed_tasks: List[str] = Field(
        default_factory=list, description="Completed task IDs"
    )
    failed_tasks: List[str] = Field(default_factory=list, description="Failed task IDs")
    performance_history: List[Dict[str, Any]] = Field(
        default_factory=list, description="Performance history"
    )
    adaptation_rules: Dict[str, Any] = Field(
        default_factory=dict, description="Curriculum adaptation rules"
    )
    progress_metrics: Dict[str, Decimal] = Field(
        default_factory=dict, description="Progress metrics"
    )
    last_task_generated: Optional[datetime] = Field(
        default=None, description="Last task generation timestamp"
    )
    generation_parameters: Dict[str, Any] = Field(
        default_factory=dict, description="Task generation parameters"
    )

    @computed_field
    @property
    def total_tasks(self) -> int:
        """Get total number of tasks."""
        return (
            len(self.active_tasks)
            + len(self.task_queue)
            + len(self.completed_tasks)
            + len(self.failed_tasks)
        )

    @computed_field
    @property
    def completion_rate(self) -> Decimal:
        """Calculate overall completion rate."""
        if self.total_tasks == 0:
            return Decimal("0")
        return (
            Decimal(str(len(self.completed_tasks))) / Decimal(str(self.total_tasks))
        ) * 100

    @computed_field
    @property
    def success_rate(self) -> Decimal:
        """Calculate task success rate."""
        total_attempted = len(self.completed_tasks) + len(self.failed_tasks)
        if total_attempted == 0:
            return Decimal("0")
        return (
            Decimal(str(len(self.completed_tasks))) / Decimal(str(total_attempted))
        ) * 100

    @computed_field
    @property
    def skill_development_progress(self) -> Decimal:
        """Calculate skill development progress."""
        if len(self.target_skills) == 0:
            return Decimal("100")
        return (
            Decimal(str(len(self.completed_skills)))
            / Decimal(str(len(self.target_skills)))
        ) * 100

    @property
    def has_active_tasks(self) -> bool:
        """Check if curriculum has active tasks."""
        return len(self.active_tasks) > 0

    @property
    def has_queued_tasks(self) -> bool:
        """Check if curriculum has queued tasks."""
        return len(self.task_queue) > 0

    @property
    def needs_task_generation(self) -> bool:
        """Check if curriculum needs new tasks."""
        return len(self.active_tasks) < 3 and len(self.task_queue) < 5

    @property
    def is_progressing_well(self) -> bool:
        """Check if curriculum is progressing well."""
        return self.success_rate > 70 and self.completion_rate > 50

    def is_valid(self) -> bool:
        """Check if curriculum is in a valid state."""
        return len(self.target_skills) > 0 and len(self.agent_id.strip()) > 0

    def get_domain_events(self) -> List[Any]:
        """Get domain events (placeholder)."""
        return []

    def should_advance_difficulty(self) -> bool:
        """Check if difficulty should be advanced."""
        if len(self.performance_history) < 5:
            return False

        # Check recent performance
        recent_performance = self.performance_history[-5:]
        avg_success = sum(p.get("success_rate", 0) for p in recent_performance) / 5

        return avg_success > 80 and self.current_difficulty != DifficultyLevel.EXPERT

    def should_reduce_difficulty(self) -> bool:
        """Check if difficulty should be reduced."""
        if len(self.performance_history) < 3:
            return False

        recent_performance = self.performance_history[-3:]
        avg_success = sum(p.get("success_rate", 0) for p in recent_performance) / 3

        return avg_success < 40 and self.current_difficulty != DifficultyLevel.BEGINNER

    def advance_difficulty(self) -> "Curriculum":
        """Advance difficulty level."""
        difficulty_order = [
            DifficultyLevel.BEGINNER,
            DifficultyLevel.INTERMEDIATE,
            DifficultyLevel.ADVANCED,
            DifficultyLevel.EXPERT,
        ]

        current_index = difficulty_order.index(self.current_difficulty)
        if current_index < len(difficulty_order) - 1:
            new_difficulty = difficulty_order[current_index + 1]
            return self.update(current_difficulty=new_difficulty)

        return self

    def reduce_difficulty(self) -> "Curriculum":
        """Reduce difficulty level."""
        difficulty_order = [
            DifficultyLevel.BEGINNER,
            DifficultyLevel.INTERMEDIATE,
            DifficultyLevel.ADVANCED,
            DifficultyLevel.EXPERT,
        ]

        current_index = difficulty_order.index(self.current_difficulty)
        if current_index > 0:
            new_difficulty = difficulty_order[current_index - 1]
            return self.update(current_difficulty=new_difficulty)

        return self

    def add_task_to_queue(
        self, task_id: str, priority: TaskPriority = TaskPriority.MEDIUM
    ) -> "Curriculum":
        """Add task to queue."""
        if priority == TaskPriority.CRITICAL:
            # Add to front of queue for critical tasks
            new_queue = [task_id] + self.task_queue
        else:
            new_queue = self.task_queue + [task_id]

        return self.update(task_queue=new_queue)

    def activate_next_task(self) -> "Curriculum":
        """Activate the next task from queue."""
        if not self.task_queue:
            return self

        next_task = self.task_queue[0]
        new_queue = self.task_queue[1:]
        new_active = {**self.active_tasks, "current": next_task}

        return self.update(task_queue=new_queue, active_tasks=new_active)

    def complete_task(
        self, task_id: str, performance_data: Dict[str, Any]
    ) -> "Curriculum":
        """Complete a task and update performance."""
        # Remove from active tasks
        new_active = {k: v for k, v in self.active_tasks.items() if v != task_id}

        # Add to completed tasks
        new_completed = self.completed_tasks + [task_id]

        # Update performance history
        performance_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "task_id": task_id,
            **performance_data,
        }
        new_history = self.performance_history + [performance_entry]

        return self.update(
            active_tasks=new_active,
            completed_tasks=new_completed,
            performance_history=new_history,
        )

    def fail_task(self, task_id: str, reason: str) -> "Curriculum":
        """Mark task as failed."""
        # Remove from active tasks
        new_active = {k: v for k, v in self.active_tasks.items() if v != task_id}

        # Add to failed tasks
        new_failed = self.failed_tasks + [task_id]

        # Record failure in performance history
        performance_entry = {
            "timestamp": datetime.utcnow().isoformat(),
            "task_id": task_id,
            "success_rate": 0,
            "failure_reason": reason,
        }
        new_history = self.performance_history + [performance_entry]

        return self.update(
            active_tasks=new_active,
            failed_tasks=new_failed,
            performance_history=new_history,
        )

    def update_progress_metrics(self, metrics: Dict[str, Decimal]) -> "Curriculum":
        """Update curriculum progress metrics."""
        updated_metrics = {**self.progress_metrics, **metrics}
        return self.update(progress_metrics=updated_metrics)

    def get_curriculum_summary(self) -> Dict[str, Any]:
        """Get curriculum summary."""
        return {
            "name": self.name,
            "agent_id": self.agent_id,
            "strategy": self.strategy.value,
            "current_difficulty": self.current_difficulty.value,
            "total_tasks": self.total_tasks,
            "active_tasks": len(self.active_tasks),
            "queued_tasks": len(self.task_queue),
            "completion_rate": float(self.completion_rate),
            "success_rate": float(self.success_rate),
            "skill_progress": float(self.skill_development_progress),
            "needs_task_generation": self.needs_task_generation,
            "should_advance_difficulty": self.should_advance_difficulty(),
            "is_progressing_well": self.is_progressing_well,
        }
