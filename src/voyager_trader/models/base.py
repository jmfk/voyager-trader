"""
Base classes and infrastructure for VOYAGER-Trader domain models.

This module provides the foundational classes for all domain models,
including base entities, value objects, and aggregate roots.
"""

import uuid
from abc import ABC, abstractmethod
from datetime import datetime, timezone
from typing import Any, Optional, TypeVar

from pydantic import BaseModel, ConfigDict, Field

T = TypeVar("T", bound="BaseEntity")


class VoyagerBaseModel(BaseModel):
    """Base model for all VOYAGER-Trader models with common configuration."""

    model_config = ConfigDict(
        # Ensure immutability for thread safety
        frozen=True,
        # Validate assignment for safety
        validate_assignment=True,
        # Use enums by value for serialization
        use_enum_values=True,
        # Populate by name for API compatibility
        populate_by_name=True,
        # Extra fields forbidden for strict validation
        extra="forbid",
        # Arbitrary types allowed for complex objects
        arbitrary_types_allowed=True,
    )


class BaseEntity(VoyagerBaseModel, ABC):
    """
    Base class for domain entities with identity.

    Entities have identity that persists over time and are mutable
    through their lifecycle, but individual instances are immutable.
    """

    id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique identifier for the entity",
    )
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Timestamp when the entity was created",
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Timestamp when the entity was last updated",
    )
    version: int = Field(default=1, description="Version number for optimistic locking")

    def __eq__(self, other: Any) -> bool:
        """Entities are equal if they have the same ID and type."""
        if not isinstance(other, self.__class__):
            return False
        return self.id == other.id

    def __hash__(self) -> int:
        """Hash based on entity ID for use in sets and dicts."""
        return hash(self.id)

    def update(self: T, **kwargs: Any) -> T:
        """
        Create a new instance with updated fields.

        Returns a new instance with the updated_at timestamp refreshed
        and version incremented.
        """
        # Handle version increment for both int and str types
        if isinstance(self.version, str):
            try:
                version_float = float(self.version)
                new_version = str(version_float + 0.1)
            except (ValueError, TypeError):
                new_version = self.version
        else:
            new_version = self.version + 1

        update_data = {
            **kwargs,
            "updated_at": datetime.now(timezone.utc),
            "version": new_version,
        }
        return self.model_copy(update=update_data)


class ValueObject(VoyagerBaseModel, ABC):
    """
    Base class for value objects.

    Value objects have no identity and are immutable. They are compared
    by their attributes rather than identity.
    """

    def __eq__(self, other: Any) -> bool:
        """Value objects are equal if all their attributes are equal."""
        if not isinstance(other, self.__class__):
            return False
        return self.model_dump() == other.model_dump()

    def __hash__(self) -> int:
        """Hash based on all attributes for use in sets and dicts."""
        return hash(tuple(self.model_dump().values()))


class AggregateRoot(BaseEntity, ABC):
    """
    Base class for aggregate roots.

    Aggregate roots are entities that serve as the entry point to
    an aggregate and maintain consistency boundaries.
    """

    @abstractmethod
    def is_valid(self) -> bool:
        """
        Check if the aggregate is in a valid state.

        Returns:
            True if the aggregate is valid, False otherwise.
        """

    @abstractmethod
    def get_domain_events(self) -> list[Any]:
        """
        Get domain events that occurred on this aggregate.

        Returns:
            List of domain events generated by this aggregate.
        """


class DomainEvent(VoyagerBaseModel):
    """
    Base class for domain events.

    Domain events represent something important that happened in the domain
    and can be used for integration between bounded contexts.
    """

    event_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique identifier for the event",
    )
    occurred_at: datetime = Field(
        default_factory=datetime.utcnow,
        description="Timestamp when the event occurred",
    )
    aggregate_id: str = Field(
        description="ID of the aggregate that generated the event"
    )
    event_type: str = Field(description="Type of the domain event")

    @classmethod
    def get_event_type(cls) -> str:
        """Get the event type for this domain event class."""
        return cls.__name__


class Repository(ABC):
    """
    Base repository interface for aggregate persistence.

    Repositories provide a collection-like interface for accessing
    aggregates while hiding persistence implementation details.
    """

    @abstractmethod
    async def find_by_id(self, entity_id: str) -> Optional[BaseEntity]:
        """Find an entity by its ID."""

    @abstractmethod
    async def save(self, entity: BaseEntity) -> BaseEntity:
        """Save an entity and return the saved instance."""

    @abstractmethod
    async def delete(self, entity_id: str) -> bool:
        """Delete an entity by its ID. Returns True if deleted."""


class Specification(ABC):
    """
    Base class for specifications that encapsulate business rules.

    Specifications can be combined using logical operators and provide
    a way to express complex business rules in a reusable way.
    """

    @abstractmethod
    def is_satisfied_by(self, entity: Any) -> bool:
        """Check if the specification is satisfied by the given entity."""

    def and_(self, other: "Specification") -> "AndSpecification":
        """Combine with another specification using logical AND."""
        return AndSpecification(self, other)

    def or_(self, other: "Specification") -> "OrSpecification":
        """Combine with another specification using logical OR."""
        return OrSpecification(self, other)

    def not_(self) -> "NotSpecification":
        """Negate this specification."""
        return NotSpecification(self)


class AndSpecification(Specification):
    """Specification that combines two specifications with logical AND."""

    def __init__(self, left: Specification, right: Specification) -> None:
        self.left = left
        self.right = right

    def is_satisfied_by(self, entity: Any) -> bool:
        return self.left.is_satisfied_by(entity) and self.right.is_satisfied_by(entity)


class OrSpecification(Specification):
    """Specification that combines two specifications with logical OR."""

    def __init__(self, left: Specification, right: Specification) -> None:
        self.left = left
        self.right = right

    def is_satisfied_by(self, entity: Any) -> bool:
        return self.left.is_satisfied_by(entity) or self.right.is_satisfied_by(entity)


class NotSpecification(Specification):
    """Specification that negates another specification."""

    def __init__(self, spec: Specification) -> None:
        self.spec = spec

    def is_satisfied_by(self, entity: Any) -> bool:
        return not self.spec.is_satisfied_by(entity)
